diff --git a/lib/yui/treeview/treeview-debug.js b/lib/yui/treeview/treeview-debug.js
index 2aa5c09..9f23998 100755
--- a/lib/yui/treeview/treeview-debug.js
+++ b/lib/yui/treeview/treeview-debug.js
@@ -1,8 +1,8 @@
 /*
-Copyright (c) 2008, Yahoo! Inc. All rights reserved.
+Copyright (c) 2010, Yahoo! Inc. All rights reserved.
 Code licensed under the BSD License:
-http://developer.yahoo.net/yui/license.txt
-version: 2.6.0
+http://developer.yahoo.com/yui/license.html
+version: 2.8.2r1
 */
 (function () {
 	var Dom = YAHOO.util.Dom,
@@ -10,12 +10,14 @@ version: 2.6.0
 		Lang = YAHOO.lang,
 		Widget = YAHOO.widget;
 
+    
+
 /**
  * The treeview widget is a generic tree building tool.
  * @module treeview
  * @title TreeView Widget
- * @requires yahoo, event
- * @optional animation
+ * @requires yahoo, dom, event
+ * @optional animation, json, calendar
  * @namespace YAHOO.widget
  */
 
@@ -25,16 +27,14 @@ version: 2.6.0
  * @class TreeView
  * @uses YAHOO.util.EventProvider
  * @constructor
- * @param {string|HTMLElement} id The id of the element, or the element itself that the tree will be inserted into.  Existing markup in this element, if valid, will be used to build the tree
- * @param {Array|object|string}  oConfig (optional)  An array containing the definition of the tree.  Objects will be converted to arrays of one element.  A string will produce a single TextNode
+ * @param {string|HTMLElement} id The id of the element, or the element itself that the tree will be inserted into.  
+ *        Existing markup in this element, if valid, will be used to build the tree
+ * @param {Array|Object|String}  oConfig (optional)  If present, it will be used to build the tree via method <a href="#method_buildTreeFromObject">buildTreeFromObject</a>
  * 
  */
 YAHOO.widget.TreeView = function(id, oConfig) {
     if (id) { this.init(id); }
 	if (oConfig) {
-		if (!Lang.isArray(oConfig)) {
-			oConfig = [oConfig];
-		}
 		this.buildTreeFromObject(oConfig);
 	} else if (Lang.trim(this._el.innerHTML)) {
 		this.buildTreeFromMarkup(id);
@@ -124,6 +124,32 @@ TV.prototype = {
      */
     _dblClickTimer: null,
 
+  /**
+     * A reference to the Node currently having the focus or null if none.
+     * @property currentFocus
+     * @type YAHOO.widget.Node
+     */
+    currentFocus: null,
+    
+    /**
+    * If true, only one Node can be highlighted at a time
+    * @property singleNodeHighlight
+    * @type boolean
+    * @default false
+    */
+    
+    singleNodeHighlight: false,
+    
+    /**
+    * A reference to the Node that is currently highlighted.
+    * It is only meaningful if singleNodeHighlight is enabled
+    * @property _currentlyHighlighted
+    * @type YAHOO.widget.Node
+    * @default null
+    * @private
+    */
+    
+    _currentlyHighlighted: null,
 
     /**
      * Sets up the animation for expanding children
@@ -138,7 +164,7 @@ TV.prototype = {
     /**
      * Sets up the animation for collapsing children
      * @method setCollapseAnim
-     * @param {string} the type of animation (acceptable values defined in 
+     * @param {string} type of animation (acceptable values defined in 
      * YAHOO.widget.TVAnim)
      */
     setCollapseAnim: function(type) {
@@ -250,8 +276,8 @@ TV.prototype = {
          * starts
          * @event animStart
          * @type CustomEvent
-         * @param {YAHOO.widget.Node} node the node that is expanding/collapsing
-         * @parm {String} type the type of animation ("expand" or "collapse")
+         * @param {YAHOO.widget.Node} oArgs.node the node that is expanding/collapsing
+         * @param {String} oArgs.type the type of animation ("expand" or "collapse")
          */
         this.createEvent("animStart", this);
 
@@ -260,8 +286,8 @@ TV.prototype = {
          * completes
          * @event animComplete
          * @type CustomEvent
-         * @param {YAHOO.widget.Node} node the node that is expanding/collapsing
-         * @parm {String} type the type of animation ("expand" or "collapse")
+         * @param {YAHOO.widget.Node} oArgs.node the node that is expanding/collapsing
+         * @param {String} oArgs.type the type of animation ("expand" or "collapse")
          */
         this.createEvent("animComplete", this);
 
@@ -320,6 +346,17 @@ TV.prototype = {
         this.createEvent("clickEvent", this);
 
 	/**
+         * Fires when the focus receives the focus, when it changes from a Node 
+    * to another Node or when it is completely lost (blurred)
+         * @event focusChanged
+         * @type CustomEvent
+         * @param oArgs.oldNode  {YAHOO.widget.Node} Node that had the focus or null if none
+         * @param oArgs.newNode {YAHOO.widget.Node} Node that receives the focus or null if none
+         */
+        
+        this.createEvent('focusChanged',this);
+
+    /**
          * Fires when the label in a TextNode or MenuNode or content in an HTMLNode receives a double Click
          * @event dblClickEvent
          * @type CustomEvent
@@ -345,6 +382,19 @@ TV.prototype = {
          */
 		this.createEvent("labelClick", this);
 
+    /**
+     * Custom event fired when the highlight of a node changes.
+     * The node that triggered the change is provided as an argument:
+     * The status of the highlight can be checked in 
+     * <a href="YAHOO.widget.Node.html#property_highlightState">nodeRef.highlightState</a>.
+     * Depending on <a href="YAHOO.widget.Node.html#property_propagateHighlight">nodeRef.propagateHighlight</a>, other nodes might have changed
+     * @event highlightEvent
+     * @type CustomEvent
+     * @param node {YAHOO.widget.Node} the node that started the change in highlighting state
+    */
+        this.createEvent("highlightEvent",this);
+     
+
 
         this._nodes = [];
 
@@ -360,6 +410,10 @@ TV.prototype = {
 
         this.logger.log("tree init: " + this.id);
 		
+		if (this._initEditor) {
+			this._initEditor();
+		}
+        
         // YAHOO.util.Event.onContentReady(this.id, this.handleAvailable, this, true);
         // YAHOO.util.Event.on(this.id, "click", this.handleClick, this, true);
     },
@@ -369,13 +423,25 @@ TV.prototype = {
         //Event.on(this.id, 
     //},
  /**
-     * Builds the TreeView from an object.  This is the method called by the constructor to build the tree when it has a second argument.
+     * Builds the TreeView from an object.  
+     * This is the method called by the constructor to build the tree when it has a second argument.
+     *  A tree can be described by an array of objects, each object corresponding to a node.
+     *  Node descriptions may contain values for any property of a node plus the following extra properties: <ul>
+     * <li>type:  can be one of the following:<ul>
+     *    <li> A shortname for a node type (<code>'text','menu','html'</code>) </li>
+     *    <li>The name of a Node class under YAHOO.widget (<code>'TextNode', 'MenuNode', 'DateNode'</code>, etc) </li>
+     *    <li>a reference to an actual class: <code>YAHOO.widget.DateNode</code></li>
+	 * </ul></li>
+     * <li>children: an array containing further node definitions</li></ul>
+	 * A string instead of an object will produce a node of type 'text' with the given string as its label.
      * @method buildTreeFromObject
-     * @param  oConfig {Array}  array containing a full description of the tree
+     * @param  oConfig {Array|Object|String}  array containing a full description of the tree.
+     *        An object or a string will be turned into an array with the given object or string as its only element.
      * 
      */
 	buildTreeFromObject: function (oConfig) {
-		this.logger.log('Building tree from object');
+        var logger = this.logger;
+        logger.log('Building tree from object');
 		var build = function (parent, oConfig) {
 			var i, item, node, children, type, NodeType, ThisType;
 			for (i = 0; i < oConfig.length; i++) {
@@ -387,7 +453,7 @@ TV.prototype = {
 					delete item.children;
 					type = item.type || 'text';
 					delete item.type;
-					switch (type.toLowerCase()) {
+                    switch (Lang.isString(type) && type.toLowerCase()) {
 						case 'text':
 							node = new Widget.TextNode(item, parent);
 							break;
@@ -398,146 +464,215 @@ TV.prototype = {
 							node = new Widget.HTMLNode(item, parent);
 							break;
 						default:
+                            if (Lang.isString(type)) {
 							NodeType = Widget[type];
+                            } else {
+                                NodeType = type;
+                            }
 							if (Lang.isObject(NodeType)) {
 								for (ThisType = NodeType; ThisType && ThisType !== Widget.Node; ThisType = ThisType.superclass.constructor) {}
 								if (ThisType) {
 									node = new NodeType(item, parent);
 								} else {
-									this.logger.log('Invalid type in node definition: ' + type,'error');
+                                    logger.log('Invalid type in node definition: ' + type,'error');
 								}
 							} else {
-								this.logger.log('Invalid type in node definition: ' + type,'error');
+                                logger.log('Invalid type in node definition: ' + type,'error');
 							}
 					}
 					if (children) {
 						build(node,children);
 					}
 				} else {
-					this.logger.log('Invalid node definition','error');
+                    logger.log('Invalid node definition','error');
 				}
 			}
 		};
+        if (!Lang.isArray(oConfig)) {
+            oConfig = [oConfig];
+        }
 							
 					
 		build(this.root,oConfig);
 	},
 /**
-     * Builds the TreeView from existing markup.   Markup should consist of &lt;UL&gt; or &lt;OL&gt; elements, possibly nested.  
-     * Depending what the &lt;LI&gt; elements contain the following will be created: <ul>
+     * Builds the TreeView from existing markup.   Markup should consist of &lt;UL&gt; or &lt;OL&gt; elements containing &lt;LI&gt; elements.  
+     * Each &lt;LI&gt; can have one element used as label and a second optional element which is to be a &lt;UL&gt; or &lt;OL&gt;
+     * containing nested nodes.
+     * Depending on what the first element of the &lt;LI&gt; element is, the following Nodes will be created: <ul>
      * 	         <li>plain text:  a regular TextNode</li>
-     * 	         <li>an (un-)ordered list: a nested branch</li>
+     *           <li>anchor &lt;A&gt;: a TextNode with its <code>href</code> and <code>target</code> taken from the anchor</li>
      * 	         <li>anything else: an HTMLNode</li></ul>
      * Only the first  outermost (un-)ordered list in the markup and its children will be parsed.
-     * Tree will be fully collapsed.
-     *  HTMLNodes have hasIcon set to true if the markup for that node has a className called hasIcon.
+     * Nodes will be collapsed unless  an  &lt;LI&gt;  tag has a className called 'expanded'.
+     * All other className attributes will be copied over to the Node className property.
+     * If the &lt;LI&gt; element contains an attribute called <code>yuiConfig</code>, its contents should be a JSON-encoded object
+     * as the one used in method <a href="#method_buildTreeFromObject">buildTreeFromObject</a>.
      * @method buildTreeFromMarkup
-     * @param {string|HTMLElement} id the id of the element that contains the markup or a reference to it.
+     * @param  id {string|HTMLElement} The id of the element that contains the markup or a reference to it.
      */
 	buildTreeFromMarkup: function (id) {
 		this.logger.log('Building tree from existing markup');
-		var build = function (parent,markup) {
-			var el, node, child, text;
+        var build = function (markup) {
+            var el, child, branch = [], config = {}, label, yuiConfig;
+            // Dom's getFirstChild and getNextSibling skip over text elements
 			for (el = Dom.getFirstChild(markup); el; el = Dom.getNextSibling(el)) {
-				if (el.nodeType == 1) {
 					switch (el.tagName.toUpperCase()) {
 						case 'LI':
-							for (child = el.firstChild; child; child = child.nextSibling) {
+                        label = '';
+                        config = {
+                            expanded: Dom.hasClass(el,'expanded'),
+                            title: el.title || el.alt || null,
+                            className: Lang.trim(el.className.replace(/\bexpanded\b/,'')) || null
+                        };
+                        // I cannot skip over text elements here because I want them for labels
+                        child = el.firstChild;
 								if (child.nodeType == 3) {
-									text = Lang.trim(child.nodeValue);
-									if (text.length) {
-										node = new Widget.TextNode(text, parent, false);
+                            // nodes with only whitespace, tabs and new lines don't count, they are probably just formatting.
+                            label = Lang.trim(child.nodeValue.replace(/[\n\t\r]*/g,''));
+                            if (label) {
+                                config.type = 'text';
+                                config.label = label;
+                            } else {
+                                child = Dom.getNextSibling(child);
+                            }
 									}
+                        if (!label) {
+                            if (child.tagName.toUpperCase() == 'A') {
+                                config.type = 'text';
+                                config.label = child.innerHTML;
+                                config.href = child.href;
+                                config.target = child.target;
+                                config.title = child.title || child.alt || config.title;
 								} else {
-									switch (child.tagName.toUpperCase()) {
+                                config.type = 'html';
+                                var d = document.createElement('div');
+                                d.appendChild(child.cloneNode(true));
+                                config.html = d.innerHTML;
+                                config.hasIcon = true;
+                            }
+                        }
+                        // see if after the label it has a further list which will become children of this node.
+                        child = Dom.getNextSibling(child);
+                        switch (child && child.tagName.toUpperCase()) {
 										case 'UL':
 										case 'OL':
-											build(node,child);
-											break;
-										case 'A':
-											node = new Widget.TextNode({
-												label:child.innerHTML,
-												href: child.href,
-												target:child.target,
-												title:child.title ||child.alt
-											},parent,false);
-											break;
-										default:
-											node = new Widget.HTMLNode(child.parentNode.innerHTML, parent, false, true);
+                                config.children = build(child);
 											break;
 									}
+                        // if there are further elements or text, it will be ignored.
+                        
+                        if (YAHOO.lang.JSON) {
+                            yuiConfig = el.getAttribute('yuiConfig');
+                            if (yuiConfig) {
+                                yuiConfig = YAHOO.lang.JSON.parse(yuiConfig);
+                                config = YAHOO.lang.merge(config,yuiConfig);
 								}
 							}
+                        
+                        branch.push(config);
 							break;
 						case 'UL':
 						case 'OL':
 							this.logger.log('ULs or OLs can only contain LI elements, not other UL or OL.  This will not work in some browsers','error');
-							build(node, el);
+                        config = {
+                            type: 'text',
+                            label: '',
+                            children: build(child)
+                        };
+                        branch.push(config);
 							break;
 					}
 				}
-			}
-		
+            return branch;
 		};
+
 		var markup = Dom.getChildrenBy(Dom.get(id),function (el) { 
 			var tag = el.tagName.toUpperCase();
 			return  tag == 'UL' || tag == 'OL';
 		});
 		if (markup.length) {
-			build(this.root, markup[0]);
+            this.buildTreeFromObject(build(markup[0]));
 		} else {
 			this.logger.log('Markup contains no UL or OL elements','warn');
 		}
 	},
     /**
-     * Renders the tree boilerplate and visible nodes
-     * @method render
+     * Returns the TD element where the event has occurred
+     * @method _getEventTargetTdEl
+     * @private
      */
-    render: function() {
-        var html = this.root.getHtml();
-        this.getEl().innerHTML = html;
-		var getTarget = function (ev) {
+    _getEventTargetTdEl: function (ev) {
 			var target = Event.getTarget(ev); 
-			if (target.tagName.toUpperCase() != 'TD') { target = Dom.getAncestorByTagName(target,'td'); }
-			if (Lang.isNull(target)) { return null; }
-			if (target.className.length === 0) {
-				target = target.previousSibling;
-				if (Lang.isNull(target)) { return null; }
+        // go up looking for a TD with a className with a ygtv prefix
+        while (target && !(target.tagName.toUpperCase() == 'TD' && Dom.hasClass(target.parentNode,'ygtvrow'))) { 
+            target = Dom.getAncestorByTagName(target,'td'); 
 			}
+        if (Lang.isNull(target)) { return null; }
+        // If it is a spacer cell, do nothing
+        if (/\bygtv(blank)?depthcell/.test(target.className)) { return null;}
+        // If it has an id, search for the node number and see if it belongs to a node in this tree.
+        if (target.id) {
+            var m = target.id.match(/\bygtv([^\d]*)(.*)/);
+            if (m && m[2] && this._nodes[m[2]]) {
 			return target;
-		};
-		if (!this._hasEvents) {
-			Event.on(
-				this.getEl(),
-				'click',
-				function (ev) {
-					var self = this,
-						el = Event.getTarget(ev),
-						node = this.getNodeByElement(el);
-					if (!node) { return; }
-						
-					var toggle = function () {
-						if (node.expanded) {
-							node.collapse();
-						} else {
-							node.expand();
 						}
+        }
+        return null;
+    },
+  /**
+     * Event listener for click events
+     * @method _onClickEvent
+     * @private
+     */
+    _onClickEvent: function (ev) {
+        var self = this,
+            td = this._getEventTargetTdEl(ev),
+            node,
+            target,
+            toggle = function (force) {
 						node.focus();
+				if (force || !node.href) {
+					node.toggle();
+					try {
+						Event.preventDefault(ev);
+					} catch (e) {
+	                    // @TODO
+	                    // For some reason IE8 is providing an event object with
+	                    // most of the fields missing, but only when clicking on
+	                    // the node's label, and only when working with inline
+	                    // editing.  This generates a "Member not found" error
+	                    // in that browser.  Determine if this is a browser
+	                    // bug, or a problem with this code.  Already checked to
+	                    // see if the problem has to do with access the event
+	                    // in the outer scope, and that isn't the problem.
+	                    // Maybe the markup for inline editing is broken.
+					}
+                }
 					};
 					
-					if (Dom.hasClass(el, node.labelStyle) || Dom.getAncestorByClassName(el,node.labelStyle)) {
+        if (!td) {
+            return; 
+        }
+
+        node = this.getNodeByElement(td);
+        if (!node) { 
+            return; 
+        }
+        
+        // exception to handle deprecated event labelClick
+        // @TODO take another look at this deprecation.  It is common for people to
+        // only be interested in the label click, so why make them have to test
+        // the node type to figure out whether the click was on the label?
+        target = Event.getTarget(ev);
+        if (Dom.hasClass(target, node.labelStyle) || Dom.getAncestorByClassName(target,node.labelStyle)) {
 						this.logger.log("onLabelClick " + node.label);
 						this.fireEvent('labelClick',node);
 					}
-					while (el && !Dom.hasClass(el.parentNode,'ygtvrow') && !/ygtv[tl][mp]h?h?/.test(el.className)) {
-						el = Dom.getAncestorByTagName(el,'td');
-					}
-					if (el) {
-						// If it is a spacer cell, do nothing
-						if (/ygtv(blank)?depthcell/.test(el.className)) { return;}
+        
 						//  If it is a toggle cell, toggle
-						if (/ygtv[tl][mp]h?h?/.test(el.className)) {
-							toggle();
+        if (/\bygtv[tl][mp]h?h?/.test(td.className)) {
+            toggle(true);
 						} else {
 							if (this._dblClickTimer) {
 								window.clearTimeout(this._dblClickTimer);
@@ -557,57 +692,54 @@ TV.prototype = {
 								}
 							}
 						}
-					}
 				},
-				this,
-				true
-			);
 			
-			Event.on(
-				this.getEl(),
-				'dblclick',
-				function (ev) {
+  /**
+     * Event listener for double-click events
+     * @method _onDblClickEvent
+     * @private
+     */
+    _onDblClickEvent: function (ev) {
 					if (!this._hasDblClickSubscriber) { return; }
-					var el = Event.getTarget(ev);
-					while (!Dom.hasClass(el.parentNode,'ygtvrow')) {
-						el = Dom.getAncestorByTagName(el,'td');
-					}
-					if (/ygtv(blank)?depthcell/.test(el.className)) { return;}
-					if (!(/ygtv[tl][mp]h?h?/.test(el.className))) {
-						this.fireEvent('dblClickEvent', {event:ev, node:this.getNodeByElement(el)}); 
+        var td = this._getEventTargetTdEl(ev);
+        if (!td) {return;}
+
+        if (!(/\bygtv[tl][mp]h?h?/.test(td.className))) {
+            this.fireEvent('dblClickEvent', {event:ev, node:this.getNodeByElement(td)}); 
 						if (this._dblClickTimer) {
 							window.clearTimeout(this._dblClickTimer);
 							this._dblClickTimer = null;
 						}
 					}
 				},
-				this,
-				true
-			);
-			Event.on(
-				this.getEl(),
-				'mouseover',
-				function (ev) {
-					var target = getTarget(ev);
-					if (target) {
-target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').replace(/h+/, 'h');
-					}
-				}
-			);
-			Event.on(
-				this.getEl(),
-				'mouseout',
-				function (ev) {
-					var target = getTarget(ev);
-					if (target) {
-						target.className = target.className.replace(/ygtv([lt])([mp])h/gi,'ygtv$1$2');
+  /**
+     * Event listener for mouse over events
+     * @method _onMouseOverEvent
+     * @private
+     */
+    _onMouseOverEvent:function (ev) {
+        var target;
+        if ((target = this._getEventTargetTdEl(ev)) && (target = this.getNodeByElement(target)) && (target = target.getToggleEl())) {
+            target.className = target.className.replace(/\bygtv([lt])([mp])\b/gi,'ygtv$1$2h');
 					}
+    },
+  /**
+     * Event listener for mouse out events
+     * @method _onMouseOutEvent
+     * @private
+     */
+    _onMouseOutEvent: function (ev) {
+        var target;
+        if ((target = this._getEventTargetTdEl(ev)) && (target = this.getNodeByElement(target)) && (target = target.getToggleEl())) {
+            target.className = target.className.replace(/\bygtv([lt])([mp])h\b/gi,'ygtv$1$2');
 				}
-			);
-			Event.on(
-				this.getEl(),
-				'keydown',
-				function (ev) {
+    },
+  /**
+     * Event listener for key down events
+     * @method _onKeyDownEvent
+     * @private
+     */
+    _onKeyDownEvent: function (ev) {
 					var target = Event.getTarget(ev),
 						node = this.getNodeByElement(target),
 						newNode = node,
@@ -622,8 +754,8 @@ target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').r
 								} else {
 									newNode = newNode.parent;
 								}
-							} while (newNode && !newNode.focus());
-							if (!newNode) { node.focus(); }
+                } while (newNode && !newNode._canHaveFocus());
+                if (newNode) { newNode.focus(); }
 							Event.preventDefault(ev);
 							break;
 						case KEY.DOWN:
@@ -635,8 +767,8 @@ target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').r
 									newNode.expand();
 									newNode = (newNode.children.length || null) && newNode.children[0];
 								}
-							} while (newNode && !newNode.focus());
-							if (!newNode) { node.focus(); }
+                } while (newNode && !newNode._canHaveFocus);
+                if (newNode) { newNode.focus();}
 							Event.preventDefault(ev);
 							break;
 						case KEY.LEFT:
@@ -647,21 +779,38 @@ target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').r
 								} else {
 									newNode = newNode.previousSibling;
 								}
-							} while (newNode && !newNode.focus());
-							if (!newNode) { node.focus(); }
+                } while (newNode && !newNode._canHaveFocus());
+                if (newNode) { newNode.focus();}
 							Event.preventDefault(ev);
 							break;
 						case KEY.RIGHT:
 							this.logger.log('RIGHT');
+				var self = this,
+					moveFocusRight,
+					focusOnExpand = function (newNode) {
+						self.unsubscribe('expandComplete',focusOnExpand);
+						moveFocusRight(newNode);
+					};
+				moveFocusRight = function (newNode) {
 							do {
+						if (newNode.isDynamic() && !newNode.childrenRendered) {
+							self.subscribe('expandComplete',focusOnExpand);
+							newNode.expand();
+							newNode = null;
+							break;
+						} else {
 								newNode.expand();
 								if (newNode.children.length) {
 									newNode = newNode.children[0];
 								} else {
 									newNode = newNode.nextSibling;
 								}
-							} while (newNode && !newNode.focus());
-							if (!newNode) { node.focus(); }
+						}
+					} while (newNode && !newNode._canHaveFocus());
+					if (newNode) { newNode.focus();}
+				};
+					
+				moveFocusRight(newNode);
 							Event.preventDefault(ev);
 							break;
 						case KEY.ENTER:
@@ -682,14 +831,14 @@ target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').r
 							this.logger.log('HOME');
 							newNode = this.getRoot();
 							if (newNode.children.length) {newNode = newNode.children[0];}
-							if (!newNode.focus()) { node.focus(); }
+                if (newNode._canHaveFocus()) { newNode.focus(); }
 							Event.preventDefault(ev);
 							break;
 						case KEY.END:
 							this.logger.log('END');
 							newNode = newNode.parent.children;
 							newNode = newNode[newNode.length -1];
-							if (!newNode.focus()) { node.focus(); }
+                if (newNode._canHaveFocus()) { newNode.focus(); }
 							Event.preventDefault(ev);
 							break;
 						// case KEY.PAGE_UP:
@@ -720,9 +869,20 @@ target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').r
 							break;
 					}
 				},
-				this,
-				true
-			);
+    /**
+     * Renders the tree boilerplate and visible nodes
+     * @method render
+     */
+    render: function() {
+        var html = this.root.getHtml(),
+            el = this.getEl();
+        el.innerHTML = html;
+        if (!this._hasEvents) {
+            Event.on(el, 'click', this._onClickEvent, this, true);
+            Event.on(el, 'dblclick', this._onDblClickEvent, this, true);
+            Event.on(el, 'mouseover', this._onMouseOverEvent, this, true);
+            Event.on(el, 'mouseout', this._onMouseOutEvent, this, true);
+            Event.on(el, 'keydown', this._onKeyDownEvent, this, true);
 		}
 		this._hasEvents = true;
     },
@@ -819,7 +979,7 @@ target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').r
         for (var i in this._nodes) {
 			if (this._nodes.hasOwnProperty(i)) {
 	            var n = this._nodes[i];
-	            if (n.data && value == n.data[property]) {
+                if ((property in n && n[property] == value) || (n.data && value == n.data[property])) {
 	                return n;
 	            }
 			}
@@ -841,7 +1001,7 @@ target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').r
         for (var i in this._nodes) {
 			if (this._nodes.hasOwnProperty(i)) {
 	            var n = this._nodes[i];
-	            if (n.data && value == n.data[property]) {
+                if ((property in n && n[property] == value) || (n.data && value == n.data[property])) {
 	                values.push(n);
 	            }
 			}
@@ -850,12 +1010,33 @@ target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').r
         return (values.length) ? values : null;
     },
 
+
+    /**
+     * Returns a collection of nodes that have passed the test function
+	 * passed as its only argument.  
+	 * The function will receive a reference to each node to be tested.  
+     * @method getNodesBy
+     * @param {function} a boolean function that receives a Node instance and returns true to add the node to the results list
+     * @return {Array} the matching collection of nodes, null if no match
+     */
+    getNodesBy: function(fn) {
+        var values = [];
+        for (var i in this._nodes) {
+            if (this._nodes.hasOwnProperty(i)) {
+                var n = this._nodes[i];
+                if (fn(n)) {
+                    values.push(n);
+                }
+            }
+        }
+        return (values.length) ? values : null;
+    },
     /**
-     * Returns the treeview node reference for an anscestor element
+     * Returns the treeview node reference for an ancestor element
      * of the node, or null if it is not contained within any node
      * in this tree.
      * @method getNodeByElement
-     * @param {HTMLElement} the element to test
+     * @param el {HTMLElement} the element to test
      * @return {YAHOO.widget.Node} a node reference or null
      */
     getNodeByElement: function(el) {
@@ -884,10 +1065,21 @@ target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').r
     },
 
     /**
+     * When in singleNodeHighlight it returns the node highlighted
+	 * or null if none.  Returns null if singleNodeHighlight is false.
+     * @method getHighlightedNode
+     * @return {YAHOO.widget.Node} a node reference or null
+     */
+	getHighlightedNode: function() {
+		return this._currentlyHighlighted;
+	},
+
+
+    /**
      * Removes the node and its children, and optionally refreshes the 
      * branch of the tree that was affected.
      * @method removeNode
-     * @param {Node} The node to remove
+     * @param {Node} node to remove
      * @param {boolean} autoRefresh automatically refreshes branch if true
      * @return {boolean} False is there was a problem, true otherwise.
      */
@@ -983,7 +1175,7 @@ target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').r
      * to make it possible to insert the branch into another part of the 
      * tree, or another tree.
      * @method popNode
-     * @param {Node} the node to remove
+     * @param {Node} node to remove
      */
     popNode: function(node) { 
         var p = node.parent;
@@ -1011,6 +1203,13 @@ target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').r
             node.nextSibling.previousSibling = node.previousSibling;
         }
 
+		if (this.currentFocus == node) {
+			this.currentFocus = null;
+		}
+		if (this._currentlyHighlighted == node) {
+			this._currentlyHighlighted = null;
+		}
+
         node.parent = null;
         node.previousSibling = null;
         node.nextSibling = null;
@@ -1042,7 +1241,7 @@ target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').r
 			var node = this._nodes[i];
 			if (node && node.destroy) {node.destroy(); }
 		}
-		el.parentNode.removeChild(el);
+        el.innerHTML = '';
 		this._hasEvents = false;
 	},
 		
@@ -1092,7 +1291,42 @@ target.className = target.className.replace(/ygtv([lt])([mp])/gi, 'ygtv$1$2h').r
      * @param node {Node} the node that was collapsed.
      * @deprecated use treeobj.subscribe("collapse") instead
      */
-    onCollapse: function(node) { }
+    onCollapse: function(node) { },
+    
+    /**
+    * Sets the value of a property for all loaded nodes in the tree.
+    * @method setNodesProperty
+    * @param name {string} Name of the property to be set
+    * @param value {any} value to be set
+    * @param refresh {boolean} if present and true, it does a refresh
+    */
+    setNodesProperty: function(name, value, refresh) {
+        this.root.setNodesProperty(name,value);
+        if (refresh) {
+            this.root.refresh();
+        }
+    },
+    /**
+    * Event listener to toggle node highlight.
+    * Can be assigned as listener to clickEvent, dblClickEvent and enterKeyPressed.
+    * It returns false to prevent the default action.
+    * @method onEventToggleHighlight
+    * @param oArgs {any} it takes the arguments of any of the events mentioned above
+    * @return {false} Always cancels the default action for the event
+    */
+    onEventToggleHighlight: function (oArgs) {
+        var node;
+        if ('node' in oArgs && oArgs.node instanceof Widget.Node) {
+            node = oArgs.node;
+        } else if (oArgs instanceof Widget.Node) {
+            node = oArgs;
+        } else {
+            return false;
+        }
+        node.toggleHighlight();
+        return false;
+    }
+        
 
 };
 
@@ -1170,47 +1404,10 @@ TV.getNode = function(treeId, nodeIndex) {
 	*/ 
 TV.FOCUS_CLASS_NAME = 'ygtvfocus';
 
-/**
- * Attempts to preload the images defined in the styles used to draw the tree by
- * rendering off-screen elements that use the styles.
- * @method YAHOO.widget.TreeView.preload
- * @param {string} prefix the prefix to use to generate the names of the
- * images to preload, default is ygtv
- * @static
- */
-TV.preload = function(e, prefix) {
-    prefix = prefix || "ygtv";
-
-    YAHOO.log("Preloading images: " + prefix, "info", "TreeView");
-
-    var styles = ["tn","tm","tmh","tp","tph","ln","lm","lmh","lp","lph","loading"];
-    // var styles = ["tp"];
-
-    var sb = [];
-    
-    // save the first one for the outer container
-    for (var i=1; i < styles.length; i=i+1) { 
-        sb[sb.length] = '<span class="' + prefix + styles[i] + '">&#160;</span>';
-    }
-
-    var f = document.createElement("div");
-    var s = f.style;
-    s.className = prefix + styles[0];
-    s.position = "absolute";
-    s.height = "1px";
-    s.width = "1px";
-    s.top = "-1000px";
-    s.left = "-1000px";
-    f.innerHTML = sb.join("");
-
-    document.body.appendChild(f);
 
-    Event.removeListener(window, "load", TV.preload);
 
-};
-
-Event.addListener(window,"load", TV.preload);
 })();
+
 (function () {
 	var Dom = YAHOO.util.Dom,
 		Lang = YAHOO.lang,
@@ -1225,7 +1422,8 @@ Event.addListener(window,"load", TV.preload);
  * be used to render this node, and any custom attributes that should be
  * stored with the node (which is available in noderef.data).
  * All values in oData will be used to set equally named properties in the node
- * as long as the node does have such properties, they are not undefined, private or functions.
+ * as long as the node does have such properties, they are not undefined, private or functions,
+ * the rest of the values will be stored in noderef.data
  * @param oParent {Node} this node's parent node
  * @param expanded {boolean} the initial expanded/collapsed state (deprecated, use oData.expanded)
  * @constructor
@@ -1280,21 +1478,6 @@ YAHOO.widget.Node.prototype = {
     depth: -1,
 
     /**
-     * The href for the node's label.  If one is not specified, the href will
-     * be set so that it toggles the node.
-     * @property href
-     * @type string
-     */
-    href: null,
-
-    /**
-     * The label href target, defaults to current window
-     * @property target
-     * @type string
-     */
-    target: "_self",
-
-    /**
      * The node's expanded/collapsed state
      * @property expanded
      * @type boolean
@@ -1418,12 +1601,63 @@ YAHOO.widget.Node.prototype = {
      */
     contentStyle: "",
 
+
     /**
      * The generated id that will contain the data passed in by the implementer.
      * @property contentElId
      * @type string
      */
     contentElId: null,
+    
+/** 
+ * Enables node highlighting.  If true, the node can be highlighted and/or propagate highlighting
+ * @property enableHighlight
+ * @type boolean
+ * @default true
+ */
+    enableHighlight: true,
+    
+/** 
+ * Stores the highlight state.  Can be any of:
+ * <ul>
+ * <li>0 - not highlighted</li>
+ * <li>1 - highlighted</li>
+ * <li>2 - some children highlighted</li>
+ * </ul>
+ * @property highlightState
+ * @type integer
+ * @default 0
+ */
+ 
+ highlightState: 0,
+ 
+ /**
+ * Tells whether highlighting will be propagated up to the parents of the clicked node
+ * @property propagateHighlightUp
+ * @type boolean
+ * @default false
+ */
+ 
+ propagateHighlightUp: false,
+ 
+ /**
+ * Tells whether highlighting will be propagated down to the children of the clicked node
+ * @property propagateHighlightDown
+ * @type boolean
+ * @default false
+ */
+ 
+ propagateHighlightDown: false,
+ 
+ /**
+  * User-defined className to be added to the Node
+  * @property className
+  * @type string
+  * @default null
+  */
+ 
+ className: null,
+ 
  /**
      * The node type
      * @property _type
@@ -1434,7 +1668,7 @@ YAHOO.widget.Node.prototype = {
     _type: "Node",
 
     /*
-    spacerPath: "http://us.i1.yimg.com/us.yimg.com/i/space.gif",
+    spacerPath: "http://l.yimg.com/a/i/space.gif",
     expandedText: "Expanded",
     collapsedText: "Collapsed",
     loadingText: "Loading",
@@ -1450,7 +1684,7 @@ YAHOO.widget.Node.prototype = {
      */
     init: function(oData, oParent, expanded) {
 
-        this.data       = oData;
+        this.data = {};
         this.children   = [];
         this.index      = YAHOO.widget.TreeView.nodeCount;
         ++YAHOO.widget.TreeView.nodeCount;
@@ -1458,8 +1692,12 @@ YAHOO.widget.Node.prototype = {
 		
 		if (Lang.isObject(oData)) {
 			for (var property in oData) {
-				if (property.charAt(0) != '_'  && oData.hasOwnProperty(property) && !Lang.isUndefined(this[property]) && !Lang.isFunction(this[property]) ) {
+                if (oData.hasOwnProperty(property)) {
+                    if (property.charAt(0) != '_'  && !Lang.isUndefined(this[property]) && !Lang.isFunction(this[property]) ) {
 					this[property] = oData[property];
+                    } else {
+                        this.data[property] = oData[property];
+                    }
 				}
 			}
 		}
@@ -1832,7 +2070,7 @@ YAHOO.widget.Node.prototype = {
      */
     expand: function(lazySource) {
         // Only expand if currently collapsed.
-        if (this.expanded && !lazySource) { 
+        if (this.isLoading || (this.expanded && !lazySource)) { 
             return; 
         }
 
@@ -1903,7 +2141,7 @@ YAHOO.widget.Node.prototype = {
         if (this.hasIcon) {
             var el = this.getToggleEl();
             if (el) {
-                el.className = el.className.replace(/ygtv(([tl][pmn]h?)|(loading))/,this.getStyle());
+                el.className = el.className.replace(/\bygtv(([tl][pmn]h?)|(loading))\b/gi,this.getStyle());
             }
         }
     },
@@ -1952,7 +2190,8 @@ YAHOO.widget.Node.prototype = {
      * @method expandAll
      */
     expandAll: function() { 
-        for (var i=0;i<this.children.length;++i) {
+        var l = this.children.length;
+        for (var i=0;i<l;++i) {
             var c = this.children[i];
             if (c.isDynamic()) {
                 this.logger.log("Not supported (lazy load + expand all)");
@@ -2058,7 +2297,8 @@ YAHOO.widget.Node.prototype = {
             return false;
         } else {
             return ( this.children.length > 0 || 
-(checkForLazyLoad && this.isDynamic() && !this.dynamicLoadComplete) );
+				(checkForLazyLoad && this.isDynamic() && !this.dynamicLoadComplete) 
+			);
         }
     },
 
@@ -2081,12 +2321,7 @@ YAHOO.widget.Node.prototype = {
 
         this.childrenRendered = false;
 
-        var sb = [];
-        sb[sb.length] = '<div class="ygtvitem" id="' + this.getElId() + '">';
-        sb[sb.length] = this.getNodeHtml();
-        sb[sb.length] = this.getChildrenHtml();
-        sb[sb.length] = '</div>';
-        return sb.join("");
+        return ['<div class="ygtvitem" id="' , this.getElId() , '">' ,this.getNodeHtml() , this.getChildrenHtml() ,'</div>'].join("");
     },
 
     /**
@@ -2101,8 +2336,7 @@ YAHOO.widget.Node.prototype = {
 
 
         var sb = [];
-        sb[sb.length] = '<div class="ygtvchildren"';
-        sb[sb.length] = ' id="' + this.getChildrenElId() + '"';
+        sb[sb.length] = '<div class="ygtvchildren" id="' + this.getChildrenElId() + '"';
 
         // This is a workaround for an IE rendering issue, the child div has layout
         // in IE, creating extra space if a leaf node is created with the expanded
@@ -2207,6 +2441,18 @@ YAHOO.widget.Node.prototype = {
     loadComplete: function() {
         this.logger.log(this.index + " loadComplete, children: " + this.children.length);
         this.getChildrenEl().innerHTML = this.completeRender();
+		if (this.propagateHighlightDown) {
+			if (this.highlightState === 1 && !this.tree.singleNodeHighlight) {
+				for (var i = 0; i < this.children.length; i++) {
+				this.children[i].highlight(true);
+			}
+			} else if (this.highlightState === 0 || this.tree.singleNodeHighlight) {
+				for (i = 0; i < this.children.length; i++) {
+					this.children[i].unhighlight(true);
+				}
+			} // if (highlighState == 2) leave child nodes with whichever highlight state they are set
+		}
+				
         this.dynamicLoadComplete = true;
         this.isLoading = false;
         this.expand(true);
@@ -2258,29 +2504,33 @@ YAHOO.widget.Node.prototype = {
         this.logger.log("Generating html");
         var sb = [];
 
-        sb[sb.length] = '<table border="0" cellpadding="0" cellspacing="0" class="ygtvdepth' + this.depth + '">';
-        sb[sb.length] = '<tr class="ygtvrow">';
+        sb[sb.length] = '<table id="ygtvtableel' + this.index + '" border="0" cellpadding="0" cellspacing="0" class="ygtvtable ygtvdepth' + this.depth;
+        if (this.enableHighlight) {
+            sb[sb.length] = ' ygtv-highlight' + this.highlightState;
+        }
+        if (this.className) {
+            sb[sb.length] = ' ' + this.className;
+        }           
+        sb[sb.length] = '"><tr class="ygtvrow">';
         
         for (var i=0;i<this.depth;++i) {
-            sb[sb.length] = '<td class="' + this.getDepthStyle(i) + '"><div class="ygtvspacer"></div></td>';
+            sb[sb.length] = '<td class="ygtvcell ' + this.getDepthStyle(i) + '"><div class="ygtvspacer"></div></td>';
         }
 
         if (this.hasIcon) {
-            sb[sb.length] = '<td'; 
-            sb[sb.length] = ' id="' + this.getToggleElId() + '"';
-            sb[sb.length] = ' class="' + this.getStyle() + '"';
-            sb[sb.length] = '><a href="#" class="ygtvspacer">&nbsp;</a></td>';
+            sb[sb.length] = '<td id="' + this.getToggleElId();
+            sb[sb.length] = '" class="ygtvcell ';
+            sb[sb.length] = this.getStyle() ;
+            sb[sb.length] = '"><a href="#" class="ygtvspacer">&#160;</a></td>';
         }
 
-        sb[sb.length] = '<td';
-        sb[sb.length] = ' id="' + this.contentElId + '"'; 
-        sb[sb.length] = ' class="' + this.contentStyle  + ' ygtvcontent" ';
+        sb[sb.length] = '<td id="' + this.contentElId; 
+        sb[sb.length] = '" class="ygtvcell ';
+        sb[sb.length] = this.contentStyle  + ' ygtvcontent" ';
         sb[sb.length] = (this.nowrap) ? ' nowrap="nowrap" ' : '';
         sb[sb.length] = ' >';
 		sb[sb.length] = this.getContentHtml();
-        sb[sb.length] = '</td>';
-        sb[sb.length] = '</tr>';
-        sb[sb.length] = '</table>';
+        sb[sb.length] = '</td></tr></table>';
 
         return sb.join("");
 
@@ -2307,7 +2557,7 @@ YAHOO.widget.Node.prototype = {
         if (this.hasIcon) {
             var el = this.getToggleEl();
             if (el) {
-                el.className = this.getStyle();
+                el.className = el.className.replace(/\bygtv[lt][nmp]h*\b/gi,this.getStyle());
             }
         }
     },
@@ -2328,7 +2578,39 @@ YAHOO.widget.Node.prototype = {
 	* @private
 	*/
 	_focusHighlightedItems: [],
+    /**
+    * DOM element that actually got the browser focus
+    * @property _focusedItem
+    * @type DOM element
+    * @private
+    */
 	_focusedItem: null,
+    
+    /**
+    * Returns true if there are any elements in the node that can 
+    * accept the real actual browser focus
+    * @method _canHaveFocus
+    * @return {boolean} success
+    * @private
+    */
+    _canHaveFocus: function() {
+        return this.getEl().getElementsByTagName('a').length > 0;
+    },
+    /**
+    * Removes the focus of previously selected Node
+    * @method _removeFocus
+    * @private
+    */
+    _removeFocus:function () {
+        if (this._focusedItem) {
+            Event.removeListener(this._focusedItem,'blur');
+            this._focusedItem = null;
+        }
+        var el;
+        while ((el = this._focusHighlightedItems.shift())) {  // yes, it is meant as an assignment, really
+            Dom.removeClass(el,YAHOO.widget.TreeView.FOCUS_CLASS_NAME );
+        }
+    },
 	/**
 	* Sets the focus on the node element.
 	* It will only be able to set the focus on nodes that have anchor elements in it.  
@@ -2340,25 +2622,24 @@ YAHOO.widget.Node.prototype = {
 	focus: function () {
 		var focused = false, self = this;
 
-		var removeListeners = function () {
-			var el;
-			if (self._focusedItem) {
-				Event.removeListener(self._focusedItem,'blur');
-				self._focusedItem = null;
+        if (this.tree.currentFocus) {
+            this.tree.currentFocus._removeFocus();
 			}
 			
-			while ((el = self._focusHighlightedItems.shift())) {  // yes, it is meant as an assignment, really
-				Dom.removeClass(el,YAHOO.widget.TreeView.FOCUS_CLASS_NAME );
+        var  expandParent = function (node) {
+            if (node.parent) {
+                expandParent(node.parent);
+                node.parent.expand();
 			}
 		};
-		removeListeners();
+        expandParent(this);
 
 		Dom.getElementsBy  ( 
 			function (el) {
-				return /ygtv(([tl][pmn]h?)|(content))/.test(el.className);
+                return (/ygtv(([tl][pmn]h?)|(content))/).test(el.className);
 			} ,
 			'td' , 
-			this.getEl().firstChild , 
+            self.getEl().firstChild , 
 			function (el) {
 				Dom.addClass(el, YAHOO.widget.TreeView.FOCUS_CLASS_NAME );
 				if (!focused) { 
@@ -2367,21 +2648,35 @@ YAHOO.widget.Node.prototype = {
 						aEl = aEl[0];
 						aEl.focus();
 						self._focusedItem = aEl;
-						Event.on(aEl,'blur',removeListeners);
+                        Event.on(aEl,'blur',function () {
+                            //console.log('f1');
+                            self.tree.fireEvent('focusChanged',{oldNode:self.tree.currentFocus,newNode:null});
+                            self.tree.currentFocus = null;
+                            self._removeFocus();
+                        });
 						focused = true;
 					}
 				}
 				self._focusHighlightedItems.push(el);
 			}
 		);
-		if (!focused) { removeListeners(); }
+        if (focused) { 
+                            //console.log('f2');
+            this.tree.fireEvent('focusChanged',{oldNode:this.tree.currentFocus,newNode:this});
+            this.tree.currentFocus = this;
+        } else {
+                            //console.log('f3');
+            this.tree.fireEvent('focusChanged',{oldNode:self.tree.currentFocus,newNode:null});
+            this.tree.currentFocus = null;
+            this._removeFocus(); 
+        }
 		return focused;
 	},
 
   /**
-     * Count of nodes in tree
+     * Count of nodes in a branch
      * @method getNodeCount
-     * @return {int} number of nodes in the tree
+     * @return {int} number of nodes in the branch
      */
     getNodeCount: function() {
 		for (var i = 0, count = 0;i< this.children.length;i++) {
@@ -2401,15 +2696,21 @@ YAHOO.widget.Node.prototype = {
 	
 		if (this.isDynamic()) { return false; }
 		
-		var def, defs = this.data, children = []; 
+        var def, defs = Lang.merge(this.data), children = []; 
+        
 		
 		
-		if (this.href) { defs.href = this.href; }
-		if (this.target != '_self') { defs.target = this.target; }
 		if (this.expanded) {defs.expanded = this.expanded; }
 		if (!this.multiExpand) { defs.multiExpand = this.multiExpand; }
+        if (!this.renderHidden) { defs.renderHidden = this.renderHidden; }
 		if (!this.hasIcon) { defs.hasIcon = this.hasIcon; }
 		if (this.nowrap) { defs.nowrap = this.nowrap; }
+        if (this.className) { defs.className = this.className; }
+        if (this.editable) { defs.editable = this.editable; }
+        if (this.enableHighlight) { defs.enableHighlight = this.enableHighlight; }
+        if (this.highlightState) { defs.highlightState = this.highlightState; }
+        if (this.propagateHighlightUp) { defs.propagateHighlightUp = this.propagateHighlightUp; }
+        if (this.propagateHighlightDown) { defs.propagateHighlightDown = this.propagateHighlightDown; }
 		defs.type = this._type;
 		
 		
@@ -2431,12 +2732,246 @@ YAHOO.widget.Node.prototype = {
      */
     getToggleLink: function() {
         return 'return false;';
+    },
+    
+    /**
+    * Sets the value of property for this node and all loaded descendants.  
+    * Only public and defined properties can be set, not methods.  
+    * Values for unknown properties will be assigned to the refNode.data object
+    * @method setNodesProperty
+    * @param name {string} Name of the property to be set
+    * @param value {any} value to be set
+    * @param refresh {boolean} if present and true, it does a refresh
+    */
+    setNodesProperty: function(name, value, refresh) {
+        if (name.charAt(0) != '_'  && !Lang.isUndefined(this[name]) && !Lang.isFunction(this[name]) ) {
+            this[name] = value;
+        } else {
+            this.data[name] = value;
+        }
+        for (var i = 0; i < this.children.length;i++) {
+            this.children[i].setNodesProperty(name,value);
+        }
+        if (refresh) {
+            this.refresh();
+        }
+    },
+    /**
+    * Toggles the highlighted state of a Node
+    * @method toggleHighlight
+    */
+    toggleHighlight: function() {
+        if (this.enableHighlight) {
+            // unhighlights only if fully highligthed.  For not or partially highlighted it will highlight
+            if (this.highlightState == 1) {
+                this.unhighlight();
+            } else {
+                this.highlight();
+            }
+        }
+    },
+    
+    /**
+    * Turns highlighting on node.  
+    * @method highlight
+    * @param _silent {boolean} optional, don't fire the highlightEvent
+    */
+    highlight: function(_silent) {
+        if (this.enableHighlight) {
+            if (this.tree.singleNodeHighlight) {
+                if (this.tree._currentlyHighlighted) {
+                    this.tree._currentlyHighlighted.unhighlight(_silent);
+                }
+                this.tree._currentlyHighlighted = this;
+            }
+            this.highlightState = 1;
+            this._setHighlightClassName();
+            if (!this.tree.singleNodeHighlight) {
+				if (this.propagateHighlightDown) {
+					for (var i = 0;i < this.children.length;i++) {
+						this.children[i].highlight(true);
+					}
+				}
+				if (this.propagateHighlightUp) {
+					if (this.parent) {
+						this.parent._childrenHighlighted();
+					}
+				}
+			}
+            if (!_silent) {
+                this.tree.fireEvent('highlightEvent',this);
+            }
+        }
+    },
+    /**
+    * Turns highlighting off a node.  
+    * @method unhighlight
+    * @param _silent {boolean} optional, don't fire the highlightEvent
+    */
+    unhighlight: function(_silent) {
+        if (this.enableHighlight) {
+			// might have checked singleNodeHighlight but it wouldn't really matter either way
+            this.tree._currentlyHighlighted = null;
+            this.highlightState = 0;
+            this._setHighlightClassName();
+            if (!this.tree.singleNodeHighlight) {
+				if (this.propagateHighlightDown) {
+					for (var i = 0;i < this.children.length;i++) {
+						this.children[i].unhighlight(true);
+					}
+				}
+				if (this.propagateHighlightUp) {
+					if (this.parent) {
+						this.parent._childrenHighlighted();
+					}
+				}
+			}
+            if (!_silent) {
+                this.tree.fireEvent('highlightEvent',this);
+            }
+        }
+    },
+    /** 
+    * Checks whether all or part of the children of a node are highlighted and
+    * sets the node highlight to full, none or partial highlight.
+    * If set to propagate it will further call the parent
+    * @method _childrenHighlighted
+    * @private
+    */
+    _childrenHighlighted: function() {
+        var yes = false, no = false;
+        if (this.enableHighlight) {
+            for (var i = 0;i < this.children.length;i++) {
+                switch(this.children[i].highlightState) {
+                    case 0:
+                        no = true;
+                        break;
+                    case 1:
+                        yes = true;
+                        break;
+                    case 2:
+                        yes = no = true;
+                        break;
+                }
+            }
+            if (yes && no) {
+                this.highlightState = 2;
+            } else if (yes) {
+                this.highlightState = 1;
+            } else {
+                this.highlightState = 0;
+            }
+            this._setHighlightClassName();
+            if (this.propagateHighlightUp) {
+                if (this.parent) {
+                    this.parent._childrenHighlighted();
+                }
+            }
+        }
+    },
+    
+    /**
+    * Changes the classNames on the toggle and content containers to reflect the current highlighting
+    * @method _setHighlightClassName
+    * @private
+    */
+    _setHighlightClassName: function() {
+        var el = Dom.get('ygtvtableel' + this.index);
+        if (el) {
+            el.className = el.className.replace(/\bygtv-highlight\d\b/gi,'ygtv-highlight' + this.highlightState);
+        }
     }
 
 };
 
 YAHOO.augment(YAHOO.widget.Node, YAHOO.util.EventProvider);
 })();
+
+/**
+ * A custom YAHOO.widget.Node that handles the unique nature of 
+ * the virtual, presentationless root node.
+ * @namespace YAHOO.widget
+ * @class RootNode
+ * @extends YAHOO.widget.Node
+ * @param oTree {YAHOO.widget.TreeView} The tree instance this node belongs to
+ * @constructor
+ */
+YAHOO.widget.RootNode = function(oTree) {
+    // Initialize the node with null params.  The root node is a
+    // special case where the node has no presentation.  So we have
+    // to alter the standard properties a bit.
+    this.init(null, null, true);
+    
+    /*
+     * For the root node, we get the tree reference from as a param
+     * to the constructor instead of from the parent element.
+     */
+    this.tree = oTree;
+};
+
+YAHOO.extend(YAHOO.widget.RootNode, YAHOO.widget.Node, {
+    
+   /**
+     * The node type
+     * @property _type
+      * @type string
+     * @private
+     * @default "RootNode"
+     */
+    _type: "RootNode",
+    
+    // overrides YAHOO.widget.Node
+    getNodeHtml: function() { 
+        return ""; 
+    },
+
+    toString: function() { 
+        return this._type;
+    },
+
+    loadComplete: function() { 
+        this.tree.draw();
+    },
+    
+   /**
+     * Count of nodes in tree.  
+    * It overrides Nodes.getNodeCount because the root node should not be counted.
+     * @method getNodeCount
+     * @return {int} number of nodes in the tree
+     */
+    getNodeCount: function() {
+        for (var i = 0, count = 0;i< this.children.length;i++) {
+            count += this.children[i].getNodeCount();
+        }
+        return count;
+    },
+
+  /**
+     * Returns an object which could be used to build a tree out of this node and its children.
+     * It can be passed to the tree constructor to reproduce this node as a tree.
+     * Since the RootNode is automatically created by treeView, 
+     * its own definition is excluded from the returned node definition
+     * which only contains its children.
+     * @method getNodeDefinition
+     * @return {Object | false}  definition of the tree or false if any child node is defined as dynamic
+     */
+    getNodeDefinition: function() {
+        
+        for (var def, defs = [], i = 0; i < this.children.length;i++) {
+            def = this.children[i].getNodeDefinition();
+            if (def === false) { return false;}
+            defs.push(def);
+        }
+        return defs;
+    },
+
+    collapse: function() {},
+    expand: function() {},
+    getSiblings: function() { return null; },
+    focus: function () {}
+
+});
+
 (function () {
 	var Dom = YAHOO.util.Dom,
 		Lang = YAHOO.lang,
@@ -2509,7 +3044,22 @@ YAHOO.extend(YAHOO.widget.TextNode, YAHOO.widget.Node, {
      */
     title: null,
 	
-/**
+    /**
+     * The href for the node's label.  If one is not specified, the href will
+     * be set so that it toggles the node.
+     * @property href
+     * @type string
+     */
+    href: null,
+
+    /**
+     * The label href target, defaults to current window
+     * @property target
+     * @type string
+     */
+    target: "_self",
+    
+    /**
      * The node type
      * @property _type
      * @private
@@ -2557,14 +3107,14 @@ YAHOO.extend(YAHOO.widget.TextNode, YAHOO.widget.Node, {
         var sb = [];
         sb[sb.length] = this.href?'<a':'<span';
         sb[sb.length] = ' id="' + this.labelElId + '"';
-        if (this.title) {
-            sb[sb.length] = ' title="' + this.title + '"';
-        }
         sb[sb.length] = ' class="' + this.labelStyle  + '"';
 		if (this.href) {
 			sb[sb.length] = ' href="' + this.href + '"';
 			sb[sb.length] = ' target="' + this.target + '"';
 		} 
+        if (this.title) {
+            sb[sb.length] = ' title="' + this.title + '"';
+        }
         sb[sb.length] = ' >';
         sb[sb.length] = this.label;
         sb[sb.length] = this.href?'</a>':'</span>';
@@ -2587,7 +3137,9 @@ YAHOO.extend(YAHOO.widget.TextNode, YAHOO.widget.Node, {
 		// Node specific properties
 		def.label = this.label;
 		if (this.labelStyle != 'ygtvlabel') { def.style = this.labelStyle; }
-		if (this.title) { def.title = this.title ; }
+        if (this.title) { def.title = this.title; }
+        if (this.href) { def.href = this.href; }
+        if (this.target != '_self') { def.target = this.target; }       
 
 		return def;
 	
@@ -2600,93 +3152,63 @@ YAHOO.extend(YAHOO.widget.TextNode, YAHOO.widget.Node, {
     // deprecated
     onLabelClick: function() {
 		return false;
+    },
+    refresh: function() {
+        YAHOO.widget.TextNode.superclass.refresh.call(this);
+        var label = this.getLabelEl();
+        label.innerHTML = this.label;
+        if (label.tagName.toUpperCase() == 'A') {
+            label.href = this.href;
+            label.target = this.target;
     }
+    }
+        
+    
+
+    
 });
 })();
+
 /**
- * A custom YAHOO.widget.Node that handles the unique nature of 
- * the virtual, presentationless root node.
+ * A menu-specific implementation that differs from TextNode in that only 
+ * one sibling can be expanded at a time.
  * @namespace YAHOO.widget
- * @class RootNode
- * @extends YAHOO.widget.Node
- * @param oTree {YAHOO.widget.TreeView} The tree instance this node belongs to
+ * @class MenuNode
+ * @extends YAHOO.widget.TextNode
+ * @param oData {object} a string or object containing the data that will
+ * be used to render this node.
+ * Providing a string is the same as providing an object with a single property named label.
+ * All values in the oData will be used to set equally named properties in the node
+ * as long as the node does have such properties, they are not undefined, private or functions.
+ * All attributes are made available in noderef.data, which
+ * can be used to store custom attributes.  TreeView.getNode(s)ByProperty
+ * can be used to retrieve a node by one of the attributes.
+ * @param oParent {YAHOO.widget.Node} this node's parent node
+ * @param expanded {boolean} the initial expanded/collapsed state (deprecated; use oData.expanded) 
  * @constructor
  */
-YAHOO.widget.RootNode = function(oTree) {
-	// Initialize the node with null params.  The root node is a
-	// special case where the node has no presentation.  So we have
-	// to alter the standard properties a bit.
-	this.init(null, null, true);
+YAHOO.widget.MenuNode = function(oData, oParent, expanded) {
+    YAHOO.widget.MenuNode.superclass.constructor.call(this,oData,oParent,expanded);
 	
 	/*
-	 * For the root node, we get the tree reference from as a param
-	 * to the constructor instead of from the parent element.
+     * Menus usually allow only one branch to be open at a time.
 	 */
-	this.tree = oTree;
+    this.multiExpand = false;
+
 };
 
-YAHOO.extend(YAHOO.widget.RootNode, YAHOO.widget.Node, {
+YAHOO.extend(YAHOO.widget.MenuNode, YAHOO.widget.TextNode, {
     
    /**
      * The node type
      * @property _type
-      * @type string
      * @private
-     * @default "RootNode"
-     */
-    _type: "RootNode",
-	
-    // overrides YAHOO.widget.Node
-    getNodeHtml: function() { 
-        return ""; 
-    },
-
-    toString: function() { 
-        return this._type;
-    },
-
-    loadComplete: function() { 
-        this.tree.draw();
-    },
-	
-   /**
-     * Count of nodes in tree.  
-    * It overrides Nodes.getNodeCount because the root node should not be counted.
-     * @method getNodeCount
-     * @return {int} number of nodes in the tree
-     */
-    getNodeCount: function() {
-		for (var i = 0, count = 0;i< this.children.length;i++) {
-			count += this.children[i].getNodeCount();
-		}
-        return count;
-    },
-
-  /**
-     * Returns an object which could be used to build a tree out of this node and its children.
-     * It can be passed to the tree constructor to reproduce this node as a tree.
-     * Since the RootNode is automatically created by treeView, 
-     * its own definition is excluded from the returned node definition
-     * which only contains its children.
-     * @method getNodeDefinition
-     * @return {Object | false}  definition of the tree or false if any child node is defined as dynamic
+    * @default "MenuNode"
      */
-    getNodeDefinition: function() {
-		
-		for (var def, defs = [], i = 0; i < this.children.length;i++) {
-			def = this.children[i].getNodeDefinition();
-			if (def === false) { return false;}
-			defs.push(def);
-		}
-		return defs;
-    },
-
-    collapse: function() {},
-    expand: function() {},
-	getSiblings: function() { return null; },
-	focus: function () {}
+    _type: "MenuNode"
 
 });
+
 (function () {
 	var Dom = YAHOO.util.Dom,
 		Lang = YAHOO.lang,
@@ -2769,13 +3291,12 @@ YAHOO.extend(YAHOO.widget.HTMLNode, YAHOO.widget.Node, {
     },
 
     /**
-     * Synchronizes the node.data, node.html, and the node's content
+     * Synchronizes the node.html, and the node's content
      * @property setHtml
      * @param o {object} An html string or object containing an html property
      */
     setHtml: function(o) {
 
-        this.data = o;
         this.html = (typeof o === "string") ? o : o.html;
 
         var el = this.getContentEl();
@@ -2806,45 +3327,7 @@ YAHOO.extend(YAHOO.widget.HTMLNode, YAHOO.widget.Node, {
 	}
 });
 })();
-/**
- * A menu-specific implementation that differs from TextNode in that only 
- * one sibling can be expanded at a time.
- * @namespace YAHOO.widget
- * @class MenuNode
- * @extends YAHOO.widget.TextNode
- * @param oData {object} a string or object containing the data that will
- * be used to render this node.
- * Providing a string is the same as providing an object with a single property named label.
- * All values in the oData will be used to set equally named properties in the node
- * as long as the node does have such properties, they are not undefined, private or functions.
- * All attributes are made available in noderef.data, which
- * can be used to store custom attributes.  TreeView.getNode(s)ByProperty
- * can be used to retrieve a node by one of the attributes.
- * @param oParent {YAHOO.widget.Node} this node's parent node
- * @param expanded {boolean} the initial expanded/collapsed state (deprecated; use oData.expanded) 
- * @constructor
- */
-YAHOO.widget.MenuNode = function(oData, oParent, expanded) {
-	YAHOO.widget.MenuNode.superclass.constructor.call(this,oData,oParent,expanded);
 
-   /*
-     * Menus usually allow only one branch to be open at a time.
-     */
-	this.multiExpand = false;
-
-};
-
-YAHOO.extend(YAHOO.widget.MenuNode, YAHOO.widget.TextNode, {
-
-    /**
-     * The node type
-     * @property _type
-     * @private
-    * @default "MenuNode"
-     */
-    _type: "MenuNode"
-
-});
 (function () {
 	var Dom = YAHOO.util.Dom,
 		Lang = YAHOO.lang,
@@ -2928,6 +3411,7 @@ YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {
 			cal = editorData.inputObject;
 		}
 
+		editorData.oldValue = this.label;
 		cal.cfg.setProperty("selected",this.label, false); 
 
 		var delim = cal.cfg.getProperty('DATE_FIELD_DELIMITER');
@@ -2939,15 +3423,16 @@ YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {
 		cal.oDomContainer.focus();
 	},
 	/**
-	* Saves the date entered in the editor into the DateNode label property and displays it.
-	* Overrides Node.saveEditorValue
-	* @method saveEditorValue
+    * Returns the value from the input element.
+    * Overrides Node.getEditorValue.
+    * @method getEditorValue
 	 * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
+     * @return {string} date entered
 	 */
-	saveEditorValue: function (editorData) {
-		var node = editorData.node, value;
+
+	getEditorValue: function (editorData) {
 		if (Lang.isUndefined(Calendar)) {
-			value = editorData.inputElement.value;
+            return editorData.inputElement.value;
 		} else {
 			var cal = editorData.inputObject,
 				date = cal.getSelectedDates()[0],
@@ -2956,16 +3441,40 @@ YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {
 			dd[cal.cfg.getProperty('MDY_DAY_POSITION') -1] = date.getDate();
 			dd[cal.cfg.getProperty('MDY_MONTH_POSITION') -1] = date.getMonth() + 1;
 			dd[cal.cfg.getProperty('MDY_YEAR_POSITION') -1] = date.getFullYear();
-			value = dd.join(cal.cfg.getProperty('DATE_FIELD_DELIMITER'));
+            return dd.join(cal.cfg.getProperty('DATE_FIELD_DELIMITER'));
 		}
+	},
 
+	/**
+    * Finally displays the newly entered date in the tree.
+    * Overrides Node.displayEditedValue.
+    * @method displayEditedValue
+     *  @param value {string} date to be displayed and stored in the node
+     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
+     */
+	displayEditedValue: function (value,editorData) {
+		var node = editorData.node;
 		node.label = value;
-		node.data.label = value;
 		node.getLabelEl().innerHTML = value;
+	},
+  /**
+     * Returns an object which could be used to build a tree out of this node and its children.
+     * It can be passed to the tree constructor to reproduce this node as a tree.
+     * It will return false if the node or any descendant loads dynamically, regardless of whether it is loaded or not.
+     * @method getNodeDefinition
+     * @return {Object | false}  definition of the node or false if this node or any descendant is defined as dynamic
+     */ 
+    getNodeDefinition: function() {
+        var def = YAHOO.widget.DateNode.superclass.getNodeDefinition.call(this);
+        if (def === false) { return false; }
+        if (this.calendarConfig) { def.calendarConfig = this.calendarConfig; }
+        return def;
 	}
 
+
 });
 })();
+
 (function () {
 	var Dom = YAHOO.util.Dom,
 		Lang = YAHOO.lang, 
@@ -2985,6 +3494,7 @@ YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {
 	* <li>buttonsContainer {HTMLelement (&lt;div&gt;)} element which holds the &lt;button&gt; elements for Ok/Cancel.  If you don't want any of the buttons, hide it via CSS styles, don't destroy it</li>
 	* <li>node {YAHOO.widget.Node} reference to the Node being edited</li>
 	* <li>saveOnEnter {boolean}, whether the Enter key should be accepted as a Save command (Esc. is always taken as Cancel), disable for multi-line input elements </li>
+    * <li>oldValue {any}  value before editing</li>
 	* </ul>
 	*  Editors are free to use this object to store additional data.
 	 * @property editorData
@@ -2999,20 +3509,66 @@ YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {
 		inputContainer:null,
 		buttonsContainer:null,
 		node:null, // which Node is being edited
-		saveOnEnter:true
+        saveOnEnter:true,
+		oldValue:undefined
 		// Each node type is free to add its own properties to this as it sees fit.
 	};
 	
 	/**
+    * Validator function for edited data, called from the TreeView instance scope, 
+    * receives the arguments (newValue, oldValue, nodeInstance) 
+    * and returns either the validated (or type-converted) value or undefined. 
+    * An undefined return will prevent the editor from closing
+    * @property validator
+    * @type function
+    * @default null
+     * @for YAHOO.widget.TreeView
+     */
+    TVproto.validator = null;
+    
+    /**
+    * Entry point for initializing the editing plug-in.  
+    * TreeView will call this method on initializing if it exists
+    * @method _initEditor
+     * @for YAHOO.widget.TreeView
+     * @private
+    */
+
+	TVproto._initEditor = function () {
+		/** 
+	 	* Fires when the user clicks on the ok button of a node editor
+	 	* @event editorSaveEvent 
+	 	* @type CustomEvent 
+	 	* @param oArgs.newValue {mixed} the new value just entered 
+	 	* @param oArgs.oldValue {mixed} the value originally in the tree 
+	 	* @param oArgs.node {YAHOO.widget.Node} the node that has the focus 
+	        * @for YAHOO.widget.TreeView
+	 	*/ 
+	 	this.createEvent("editorSaveEvent", this); 
+		
+		/** 
+	 	* Fires when the user clicks on the cancel button of a node editor
+	 	* @event editorCancelEvent 
+	 	* @type CustomEvent 
+	 	* @param {YAHOO.widget.Node} node the node that has the focus 
+	        * @for YAHOO.widget.TreeView
+	 	*/ 
+	 	this.createEvent("editorCancelEvent", this); 
+
+	};
+
+    /**
 	* Entry point of the editing plug-in.  
 	* TreeView will call this method if it exists when a node label is clicked
 	* @method _nodeEditing
 	* @param node {YAHOO.widget.Node} the node to be edited
 	* @return {Boolean} true to indicate that the node is editable and prevent any further bubbling of the click.
 	 * @for YAHOO.widget.TreeView
+     * @private
 	*/
 	
 	
+    
 	TVproto._nodeEditing = function (node) {
 		if (node.fillEditorContainer && node.editable) {
 			var ed, topLeft, buttons, button, editorData = TV.editorData;
@@ -3115,13 +3671,19 @@ YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {
 	
 	TVproto._closeEditor = function (save) {
 		var ed = TV.editorData, 
-			node = ed.node;
+            node = ed.node,
+            close = true;
 		if (save) { 
-			ed.node.saveEditorValue(ed); 
+            close = ed.node.saveEditorValue(ed) !== false; 
+        } else {
+			this.fireEvent( 'editorCancelEvent', node); 
 		}
+			
+        if (close) {
 		Dom.setStyle(ed.editorPanel,'display','none');	
 		ed.active = false;
 		node.focus();
+        }
 	};
 	
 	/**
@@ -3178,8 +3740,8 @@ YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {
 
 	
 	/**
-	* Node-specific destroy function to empty the contents of the inline editor panel
-	* This function is the worst case alternative that will purge all possible events and remove the editor contents
+    * Node-specific destroy function to empty the contents of the inline editor panel.
+    * This function is the worst case alternative that will purge all possible events and remove the editor contents.
 	* Method Event.purgeElement is somewhat costly so if it can be replaced by specifc Event.removeListeners, it is better to do so.
 	* @method destroyEditorContents
 	 * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
@@ -3194,12 +3756,56 @@ YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {
 
 	/**
 	* Saves the value entered into the editor.
-	* Should be overridden by each node type
 	* @method saveEditorValue
 	 * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
+     * @return {false or none} a return of exactly false will prevent the editor from closing
 	 * @for YAHOO.widget.Node
 	 */
 	Nproto.saveEditorValue = function (editorData) {
+        var node = editorData.node, 
+			value,
+            validator = node.tree.validator;
+			
+		value = this.getEditorValue(editorData);
+        
+        if (Lang.isFunction(validator)) {
+            value = validator(value,editorData.oldValue,node);
+            if (Lang.isUndefined(value)) { 
+				return false; 
+			}
+        }
+
+		if (this.tree.fireEvent( 'editorSaveEvent', {
+			newValue:value,
+			oldValue:editorData.oldValue,
+			node:node
+		}) !== false) {
+			this.displayEditedValue(value,editorData);
+		}
+	};
+	
+	
+    /**
+    * Returns the value(s) from the input element(s) .
+    * Should be overridden by each node type.
+    * @method getEditorValue
+     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
+     * @return {any} value entered
+     * @for YAHOO.widget.Node
+     */
+
+	 Nproto.getEditorValue = function (editorData) {
+	};
+
+	/**
+    * Finally displays the newly edited value(s) in the tree.
+    * Should be overridden by each node type.
+    * @method displayEditedValue
+     *  @param value {any} value to be displayed and stored in the node
+     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
+     * @for YAHOO.widget.Node
+     */
+	Nproto.displayEditedValue = function (value,editorData) {
 	};
 	
 	var TNproto = YAHOO.widget.TextNode.prototype;
@@ -3207,7 +3813,7 @@ YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {
 
 
 	/** 
-	 *  Places an &lt;input&gt;  textbox in the input container and loads the label text into it
+     *  Places an &lt;input&gt;  textbox in the input container and loads the label text into it.
 	 * @method fillEditorContainer
 	 * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
 	 * @return void
@@ -3228,30 +3834,43 @@ YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {
 			// if the last node edited was of the same time, reuse the input element.
 			input = editorData.inputElement;
 		}
-
+		editorData.oldValue = this.label;
 		input.value = this.label;
 		input.focus();
 		input.select();
 	};
 	
 	/**
-	* Saves the value entered in the editor into the TextNode label property and displays it
-	* Overrides Node.saveEditorValue
-	* @method saveEditorValue
+    * Returns the value from the input element.
+    * Overrides Node.getEditorValue.
+    * @method getEditorValue
+     * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
+     * @return {string} value entered
+     * @for YAHOO.widget.TextNode
+     */
+
+    TNproto.getEditorValue = function (editorData) {
+        return editorData.inputElement.value;
+	};
+
+	/**
+    * Finally displays the newly edited value in the tree.
+    * Overrides Node.displayEditedValue.
+    * @method displayEditedValue
+     *  @param value {string} value to be displayed and stored in the node
 	 * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
 	 * @for YAHOO.widget.TextNode
 	 */
-	TNproto.saveEditorValue = function (editorData) {
-		var node = editorData.node, value = editorData.inputElement.value;
+	TNproto.displayEditedValue = function (value,editorData) {
+		var node = editorData.node;
 		node.label = value;
-		node.data.label = value;
 		node.getLabelEl().innerHTML = value;
 	};
 
 	/**
-	* Destroys the contents of the inline editor panel
-	* Overrides Node.destroyEditorContent
-	* Since we didn't set any event listeners on this inline editor, it is more efficient to avoid the generic method in Node
+    * Destroys the contents of the inline editor panel.
+    * Overrides Node.destroyEditorContent.
+    * Since we didn't set any event listeners on this inline editor, it is more efficient to avoid the generic method in Node.
 	* @method destroyEditorContents
 	 * @param editorData {YAHOO.widget.TreeView.editorData}  a shortcut to the static object holding editing information
 	 * @for YAHOO.widget.TextNode
@@ -3260,6 +3879,7 @@ YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {
 		editorData.inputContainer.innerHTML = '';
 	};
 })();
+
 /**
  * A static factory class for tree view expand/collapse animations
  * @class TVAnim
@@ -3312,6 +3932,7 @@ YAHOO.widget.TVAnim = function() {
         }
     };
 } ();
+
 /**
  * A 1/2 second fade-in animation.
  * @class TVFadeIn
@@ -3373,6 +3994,7 @@ YAHOO.widget.TVFadeIn.prototype = {
         return "TVFadeIn";
     }
 };
+
 /**
  * A 1/2 second fade out animation.
  * @class TVFadeOut
@@ -3418,7 +4040,7 @@ YAHOO.widget.TVFadeOut.prototype = {
     onComplete: function() {
         var s = this.el.style;
         s.display = "none";
-        // s.opacity = 1;
+        s.opacity = 1;
         s.filter = "alpha(opacity=100)";
         this.callback();
     },
@@ -3432,4 +4054,5 @@ YAHOO.widget.TVFadeOut.prototype = {
         return "TVFadeOut";
     }
 };
-YAHOO.register("treeview", YAHOO.widget.TreeView, {version: "2.6.0", build: "1321"});
+
+YAHOO.register("treeview", YAHOO.widget.TreeView, {version: "2.8.2r1", build: "7"});
